/**
 * Sistema de comunicação entre bactérias
 * Permite que as bactérias troquem mensagens, formem relacionamentos e interajam socialmente
 */
class BacteriaCommunication {
    /**
     * Inicializa o sistema de comunicação
     * @param {Simulation} simulation - Referência para a simulação
     */
    constructor(simulation) {
        this.simulation = simulation;
        this.messages = [];               // Histórico de mensagens recentes
        this.maxMessages = 50;            // Número máximo de mensagens no histórico
        this.relationships = new Map();   // Mapa de relacionamentos entre bactérias
        this.communicationRange = 100;    // Distância máxima para comunicação direta
        this.randomMessageChance = 0.003; // Chance de enviar mensagem aleatória por frame (ajustado pela social)
        this.userCanChat = true;          // Se o usuário pode enviar mensagens
        
        // Tipos de mensagens possíveis
        this.messageTypes = {
            GREETING: 'greeting',         // Cumprimento básico
            FOOD_INFO: 'food_info',       // Informação sobre comida
            DANGER_WARNING: 'danger',     // Aviso sobre predadores
            HELP_REQUEST: 'help',         // Pedido de ajuda
            FRIENDSHIP: 'friendship',     // Proposta de amizade
            AGGRESSIVE: 'aggressive',     // Mensagem agressiva
            MATING: 'mating',             // Relacionado à reprodução
            RANDOM: 'random',             // Conversa aleatória
            USER: 'user'                  // Mensagem do usuário
        };
        
        // Inicializa os elementos da interface
        this.initializeInterface();
    }

    /**
     * Inicializa a interface de chat usando os elementos HTML existentes
     */
    initializeInterface() {
        // Referências para os elementos HTML existentes
        this.chatInterface = document.getElementById('chat-container');
        this.messagesContainer = document.getElementById('chat-messages');
        this.userMessageInput = document.getElementById('chat-input');
        
        // Habilita o campo de entrada
        if (this.userMessageInput) {
            this.userMessageInput.removeAttribute('disabled');
            this.userMessageInput.setAttribute('placeholder', 'Digite sua mensagem...');
        }
        
        // Configura os botões existentes
        const sendButton = document.querySelector('.enviar-btn') || document.getElementById('send-chat-btn');
        const clearButton = document.querySelector('.limpar-btn') || document.getElementById('clear-chat-btn');
        
        // Se os botões não existirem, usamos os elementos que já estão no DOM
        if (sendButton) {
            this.sendButton = sendButton;
            this.sendButton.addEventListener('click', () => this.sendUserMessage());
        }
        
        if (clearButton) {
            this.clearButton = clearButton;
            this.clearButton.addEventListener('click', () => this.clearChat());
        }
        
        // Permite enviar com a tecla Enter
        if (this.userMessageInput) {
            this.userMessageInput.addEventListener('keypress', (e) => {
                if (e.key === 'Enter') {
                    this.sendUserMessage();
                }
            });
        }
        
        // Adiciona estatísticas ao container existente
        const statsElement = document.createElement('div');
        statsElement.id = 'chat-stats';
        statsElement.className = 'estatisticas-de-comunicacao';
        statsElement.style.fontSize = '11px';
        statsElement.style.padding = '10px';
        statsElement.style.backgroundColor = 'rgba(40, 40, 50, 0.7)';
        statsElement.style.borderRadius = '4px';
        statsElement.style.marginTop = '10px';
        
        if (this.chatInterface) {
            const existingStats = document.getElementById('chat-stats');
            if (!existingStats) {
                this.chatInterface.appendChild(statsElement);
                this.statsContainer = statsElement;
                this.statsContainer.innerHTML = 'Estatísticas de Comunicação<br>Total de mensagens: 0<br>Amizades formadas: 0<br>Conflitos: 0';
            } else {
                this.statsContainer = existingStats;
            }
        }
    }
    
    /**
     * Envia a mensagem do usuário para as bactérias
     */
    sendUserMessage() {
        // Verifica se temos o elemento de input
        if (!this.userMessageInput) {
            console.error("Elemento de input não encontrado");
            return;
        }
        
        const message = this.userMessageInput.value.trim();
        
        if (message && this.simulation.bacteria.length > 0) {
            // Seleciona uma bactéria aleatória para receber a mensagem
            const targetBacteria = random(this.simulation.bacteria);
            
            // Cria o objeto da mensagem
            const userMessage = {
                senderId: 'USER',
                receiverId: this.getBacteriaId(targetBacteria),
                isFemale: false,
                type: this.messageTypes.USER,
                content: message,
                time: this.getFormattedTime()
            };
            
            // Adiciona a mensagem ao histórico
            this.addMessage(userMessage);
            
            // Limpa o campo de texto
            this.userMessageInput.value = '';
            
            // Programa uma resposta da bactéria
            this.scheduleResponse(targetBacteria);
        }
    }
    
    /**
     * Programa uma resposta da bactéria para a mensagem do usuário
     * @param {Bacteria} bacteria - Bactéria que responderá
     */
    scheduleResponse(bacteria) {
        // Atraso baseado na sociabilidade da bactéria (mais sociável = responde mais rápido)
        const sociability = bacteria.dna?.genes?.sociability || 1;
        const delay = map(sociability, 0.5, 1.5, 3000, 1000); // Entre 1 e 3 segundos
        
        setTimeout(() => {
            if (this.simulation.bacteria.includes(bacteria)) {
                // Apenas responde se a bactéria ainda estiver viva
                const response = this.generateBacteriaResponse(bacteria);
                
                const responseMessage = {
                    senderId: this.getBacteriaId(bacteria),
                    receiverId: 'USER',
                    isFemale: bacteria.isFemale,
                    type: this.messageTypes.RANDOM,
                    content: response,
                    time: this.getFormattedTime()
                };
                
                this.addMessage(responseMessage);
            }
        }, delay);
    }
    
    /**
     * Gera uma resposta da bactéria para o usuário
     * @param {Bacteria} bacteria - Bactéria que responde
     * @returns {string} - Resposta gerada
     */
    generateBacteriaResponse(bacteria) {
        // Personalidade baseada no DNA
        const sociability = bacteria.dna?.genes?.sociability || 1;
        const aggressiveness = bacteria.dna?.genes?.aggressiveness || 1;
        const curiosity = bacteria.dna?.genes?.curiosity || 1;
        
        // Decide o tipo de resposta baseado na personalidade
        let responseType;
        
        if (aggressiveness > 1.2) {
            responseType = 'aggressive';
        } else if (sociability > 1.2) {
            responseType = 'friendly';
        } else if (curiosity > 1.2) {
            responseType = 'curious';
        } else {
            responseType = 'neutral';
        }
        
        // Respostas possíveis baseadas na personalidade
        const responses = {
            aggressive: [
                "Não me incomode, humano!",
                "O que você quer? Estou ocupada sobrevivendo aqui.",
                "Preciso de espaço, não de conversas.",
                "Se não tem comida para oferecer, me deixe em paz."
            ],
            friendly: [
                "Olá, humano! É bom conversar com você!",
                "Estou feliz que se interessou por mim!",
                "Que dia lindo para uma conversa, não é?",
                "Adoro conhecer novas formas de vida!"
            ],
            curious: [
                "Como é ser um humano? Deve ser fascinante!",
                "Você consegue ver todo o ambiente? Que incrível!",
                "O que mais existe além desta simulação?",
                "Por que você criou este mundo para nós?"
            ],
            neutral: [
                "Olá, estou tentando sobreviver aqui.",
                "Preciso continuar procurando comida.",
                "Este ambiente é interessante, não acha?",
                "Existem muitos desafios para uma bactéria."
            ]
        };
        
        // Saúde e energia afetam a resposta
        let healthStatus = "";
        if (bacteria.health < 30) {
            healthStatus = " Estou com pouca saúde, preciso me recuperar.";
        } else if (bacteria.energy < 30) {
            healthStatus = " Estou com fome, preciso encontrar comida.";
        }
        
        // Seleciona uma resposta aleatória do tipo determinado
        return random(responses[responseType]) + healthStatus;
    }
    
    /**
     * Limpa todas as mensagens do chat
     */
    clearChat() {
        if (this.messagesContainer) {
            // Preserva apenas a mensagem do sistema inicial
            const systemMessage = this.messagesContainer.querySelector('.message.system');
            this.messagesContainer.innerHTML = '';
            
            if (systemMessage) {
                this.messagesContainer.appendChild(systemMessage);
            }
            
            // Limpa o array de mensagens
            this.messages = [];
            
            // Atualiza estatísticas
            this.updateChatInterface();
        }
    }
    
    /**
     * Atualiza a interface do chat
     */
    updateChatInterface() {
        // Atualiza estatísticas se existir o container
        if (this.statsContainer) {
            const totalMessages = this.messages.length;
            const friendships = this.countRelationships('friendship');
            const conflicts = this.countRelationships('conflict');
            
            this.statsContainer.innerHTML = `
                <div>Total de mensagens: <strong>${totalMessages}</strong></div>
                <div>Amizades formadas: <strong>${friendships}</strong></div>
                <div>Conflitos: <strong>${conflicts}</strong></div>
            `;
        }
    }
    
    /**
     * Adiciona uma mensagem ao histórico e à interface
     * @param {Object} message - Objeto da mensagem
     */
    addMessage(message) {
        // Adiciona no array de mensagens
        this.messages.push(message);
        
        // Limita o tamanho do histórico
        if (this.messages.length > this.maxMessages) {
            this.messages.shift();
        }
        
        // Adiciona à interface se existir
        if (this.messagesContainer) {
            // Cria o elemento da mensagem
            const messageElement = document.createElement('div');
            
            // Define a classe apropriada
            let messageClass = 'message';
            if (message.senderId === 'USER') {
                messageClass += ' user';
            } else if (message.type === this.messageTypes.DANGER_WARNING) {
                messageClass += ' predator';
            } else {
                messageClass += ' bacteria';
            }
            
            messageElement.className = messageClass;
            
            // Define o conteúdo
            const sender = message.senderId === 'USER' ? 'Você' : `Bactéria #${message.senderId.substring(0, 4)}`;
            const receiver = message.receiverId === 'USER' ? 'você' : `Bactéria #${message.receiverId.substring(0, 4)}`;
            
            let content = '';
            if (message.senderId === 'USER') {
                content = `${message.content}`;
            } else if (message.receiverId === 'USER') {
                content = `${message.content}`;
            } else {
                content = `${message.content}`;
            }
            
            messageElement.textContent = content;
            
            // Adiciona ao container
            this.messagesContainer.appendChild(messageElement);
            
            // Scroll para a última mensagem
            this.messagesContainer.scrollTop = this.messagesContainer.scrollHeight;
        }
        
        // Usa a função global se disponível
        if (typeof window.addMessage === 'function') {
            const messageType = message.senderId === 'USER' ? 'user' : (message.type === this.messageTypes.DANGER_WARNING ? 'predator' : 'bacteria');
            window.addMessage(message.content, messageType);
        }
        
        // Atualiza estatísticas
        this.updateChatInterface();
    }

    /**
     * Conta o número de relacionamentos de determinado tipo
     * @param {string} type - Tipo de relacionamento ('friend', 'enemy', etc)
     * @returns {number} - Número de relacionamentos desse tipo
     */
    countRelationships(type) {
        let count = 0;
        for (const relations of this.relationships.values()) {
            for (const relation of relations) {
                if (relation.type === type) {
                    count++;
                }
            }
        }
        // Como cada relacionamento é contado duas vezes (uma para cada bactéria)
        return count / 2;
    }

    /**
     * Atualiza o sistema de comunicação
     */
    update() {
        // Verifica se há bactérias próximas para comunicação
        this.checkBacteriaCommunication();
        
        // Atualiza a interface de chat
        this.updateChatInterface();
    }

    /**
     * Verifica bactérias próximas umas das outras para possível comunicação
     */
    checkBacteriaCommunication() {
        const bacteria = this.simulation.bacteria;
        
        // Usa o grid espacial se disponível
        if (this.simulation.spatialGrid) {
            for (let i = 0; i < bacteria.length; i++) {
                const b1 = bacteria[i];
                
                // Chance de iniciar comunicação baseada no gene de sociabilidade
                const communicationChance = this.randomMessageChance * (b1.dna.genes.sociability * 2);
                
                // Tenta iniciar comunicação aleatória
                if (random() < communicationChance) {
                    // Busca bactérias próximas usando o grid espacial
                    const nearbyEntities = this.simulation.spatialGrid.queryRadius(b1.pos, this.communicationRange);
                    const nearbyBacteria = nearbyEntities.filter(e => e instanceof Bacteria && e !== b1);
                    
                    if (nearbyBacteria.length > 0) {
                        // Seleciona uma bactéria aleatória próxima
                        const b2 = random(nearbyBacteria);
                        this.createCommunication(b1, b2);
                    }
                }
            }
        } else {
            // Fallback se o grid espacial não estiver disponível (método menos eficiente)
            for (let i = 0; i < bacteria.length; i++) {
                const b1 = bacteria[i];
                
                // Menor chance de comunicação para evitar sobrecarga no método não otimizado
                const communicationChance = this.randomMessageChance * 0.5 * b1.dna.genes.sociability;
                
                if (random() < communicationChance) {
                    for (let j = 0; j < bacteria.length; j++) {
                        if (i === j) continue;
                        
                        const b2 = bacteria[j];
                        const distance = dist(b1.pos.x, b1.pos.y, b2.pos.x, b2.pos.y);
                        
                        if (distance <= this.communicationRange) {
                            this.createCommunication(b1, b2);
                            break; // Apenas uma comunicação por vez
                        }
                    }
                }
            }
        }
    }

    /**
     * Cria uma comunicação entre duas bactérias
     * @param {Bacteria} sender - Bactéria que inicia a comunicação
     * @param {Bacteria} receiver - Bactéria que recebe a comunicação
     */
    createCommunication(sender, receiver) {
        // Determina o tipo de comunicação baseado no contexto
        const msgType = this.determineMessageType(sender, receiver);
        
        // Gera o conteúdo da mensagem
        const content = this.generateMessage(sender, receiver, msgType);
        
        // Cria o objeto da mensagem
        const message = {
            senderId: this.getBacteriaId(sender),
            receiverId: this.getBacteriaId(receiver),
            isFemale: sender.isFemale,
            type: msgType,
            content: content,
            time: this.getFormattedTime()
        };
        
        // Adiciona a mensagem ao histórico
        this.addMessage(message);
        
        // Atualiza relacionamentos
        this.updateRelationship(sender, receiver, msgType);
    }

    /**
     * Determina o tipo de mensagem baseado no contexto e estado das bactérias
     * @param {Bacteria} sender - Bactéria que envia a mensagem
     * @param {Bacteria} receiver - Bactéria que recebe a mensagem
     * @returns {string} - Tipo de mensagem
     */
    determineMessageType(sender, receiver) {
        // Verifica relacionamento atual
        const relationship = this.getRelationship(sender, receiver);
        
        // Verifica se há predadores próximos
        const predatorNearby = this.simulation.predators.some(p => 
            dist(sender.pos.x, sender.pos.y, p.pos.x, p.pos.y) < sender.perceptionRadius
        );
        
        // Verifica o estado atual das bactérias
        const senderState = sender.states.getCurrentState();
        const receiverState = receiver.states.getCurrentState();
        
        // Pode avisar sobre perigo
        if (predatorNearby && random() < 0.7) {
            return this.messageTypes.DANGER_WARNING;
        }
        
        // Se estiver com pouca energia, pode pedir comida
        if (sender.states.getEnergy() < 30 && random() < 0.5) {
            return this.messageTypes.HELP_REQUEST;
        }
        
        // Se estiver procurando comida, pode compartilhar informação
        if (senderState === 'seekingFood' && random() < 0.4) {
            return this.messageTypes.FOOD_INFO;
        }
        
        // Pode tentar reprodução se for de sexos opostos e tiver energia
        if (sender.isFemale !== receiver.isFemale && 
            sender.states.getEnergy() > 60 && 
            receiver.states.getEnergy() > 60 &&
            random() < 0.3) {
            return this.messageTypes.MATING;
        }
        
        // Se for agressivo, chance de mensagem agressiva
        if (sender.dna.genes.aggressiveness > 0.7 && random() < 0.4) {
            return this.messageTypes.AGGRESSIVE;
        }
        
        // Se for sociável, chance de amizade
        if (sender.dna.genes.sociability > 0.7 && random() < 0.3) {
            return this.messageTypes.FRIENDSHIP;
        }
        
        // Se for o primeiro contato, provavelmente é um cumprimento
        if (!relationship && random() < 0.5) {
            return this.messageTypes.GREETING;
        }
        
        // Caso contrário, mensagem aleatória
        return this.messageTypes.RANDOM;
    }

    /**
     * Gera uma mensagem baseada no tipo
     * @param {Bacteria} sender - Bactéria que envia
     * @param {Bacteria} receiver - Bactéria que recebe
     * @param {string} type - Tipo de mensagem
     * @returns {string} - Conteúdo da mensagem
     */
    generateMessage(sender, receiver, type) {
        const receiverId = this.getBacteriaId(receiver);
        
        // Mensagens por tipo
        const messages = {
            [this.messageTypes.GREETING]: [
                `Olá! Prazer em conhecer você.`,
                `Oi, como vai? Sou nova por aqui.`,
                `Hey! Tudo bem com você?`,
                `Olá, parente! Como está o ambiente?`
            ],
            [this.messageTypes.FOOD_INFO]: [
                `Tem comida para o lado ${this.getRandomDirection()}.`,
                `Encontrei recursos perto daqui!`,
                `Venha comigo, achei uma fonte de energia.`,
                `Já comeu hoje? Tem bastante comida ali.`
            ],
            [this.messageTypes.DANGER_WARNING]: [
                `CUIDADO! Predador se aproximando!`,
                `PERIGO! Fuja para o lado ${this.getRandomDirection()}!`,
                `Alerta! Tem um predador por perto!`,
                `Estamos em perigo! Predador à vista!`
            ],
            [this.messageTypes.HELP_REQUEST]: [
                `Estou com pouca energia, pode me ajudar?`,
                `Preciso de comida, você sabe onde tem?`,
                `Socorro! Estou sem energia.`,
                `Pode me dizer onde encontrar recursos?`
            ],
            [this.messageTypes.FRIENDSHIP]: [
                `Gostei de você, vamos ser amigos!`,
                `Podemos formar uma aliança?`,
                `Você parece legal, vamos cooperar?`,
                `Seu DNA parece interessante, vamos nos aproximar!`
            ],
            [this.messageTypes.AGGRESSIVE]: [
                `Saia do meu caminho!`,
                `Este território é meu, saia daqui!`,
                `Você é fraco, não vai sobreviver muito.`,
                `Não se aproxime da minha comida!`
            ],
            [this.messageTypes.MATING]: [
                `Nossos genes combinam bem, que tal nos reproduzirmos?`,
                `Você parece ter bons genes. Vamos criar uma nova geração?`,
                `Que tal compartilharmos nosso DNA?`,
                `Estou pronto para reproduzir, e você?`
            ],
            [this.messageTypes.RANDOM]: [
                `Percebeu como o ambiente mudou hoje?`,
                `Você é de qual geração?`,
                `Como está sua energia?`,
                `Esse ambiente está ficando interessante!`,
                `Já viu quantos predadores têm por aí?`,
                `Acabei de me dividir, me sinto renovado!`,
                `Quais seus genes mais fortes?`,
                `Você está buscando mais comida?`
            ]
        };
        
        // Seleciona uma mensagem aleatória do tipo especificado
        return random(messages[type] || messages[this.messageTypes.RANDOM]);
    }

    /**
     * Retorna uma direção aleatória para mensagens
     * @returns {string} - Direção (norte, sul, leste, oeste)
     */
    getRandomDirection() {
        const directions = ['norte', 'sul', 'leste', 'oeste'];
        return random(directions);
    }

    /**
     * Atualiza o relacionamento entre duas bactérias com base na comunicação
     * @param {Bacteria} b1 - Primeira bactéria
     * @param {Bacteria} b2 - Segunda bactéria
     * @param {string} messageType - Tipo de mensagem trocada
     */
    updateRelationship(b1, b2, messageType) {
        // Obtém os IDs das bactérias
        const id1 = this.getBacteriaId(b1);
        const id2 = this.getBacteriaId(b2);
        
        // Inicializa relacionamentos se não existirem
        if (!this.relationships.has(id1)) {
            this.relationships.set(id1, []);
        }
        if (!this.relationships.has(id2)) {
            this.relationships.set(id2, []);
        }
        
        // Obtém os relacionamentos existentes
        let rel1 = this.relationships.get(id1).find(r => r.partnerId === id2);
        let rel2 = this.relationships.get(id2).find(r => r.partnerId === id1);
        
        // Se não existirem, cria novos
        if (!rel1) {
            rel1 = { partnerId: id2, level: 0, type: 'neutral', interactions: 0 };
            this.relationships.get(id1).push(rel1);
        }
        if (!rel2) {
            rel2 = { partnerId: id1, level: 0, type: 'neutral', interactions: 0 };
            this.relationships.get(id2).push(rel2);
        }
        
        // Atualiza o número de interações
        rel1.interactions++;
        rel2.interactions++;
        
        // Altera o nível de relação baseado no tipo de mensagem
        let change = 0;
        
        switch (messageType) {
            case this.messageTypes.GREETING:
                change = 1;
                break;
            case this.messageTypes.FOOD_INFO:
                change = 2;
                break;
            case this.messageTypes.DANGER_WARNING:
                change = 3;
                break;
            case this.messageTypes.HELP_REQUEST:
                change = random() < 0.5 ? 1 : -1; // Pode ser visto como fraqueza
                break;
            case this.messageTypes.FRIENDSHIP:
                change = 3;
                break;
            case this.messageTypes.AGGRESSIVE:
                change = -3;
                break;
            case this.messageTypes.MATING:
                change = 2;
                break;
            case this.messageTypes.RANDOM:
                change = random() < 0.7 ? 1 : -1;
                break;
        }
        
        // Aplica a mudança
        rel1.level += change;
        rel2.level += change;
        
        // Atualiza o tipo de relacionamento
        this.updateRelationshipType(rel1);
        this.updateRelationshipType(rel2);
    }

    /**
     * Atualiza o tipo de relacionamento baseado no nível
     * @param {Object} relationship - Objeto de relacionamento
     */
    updateRelationshipType(relationship) {
        if (relationship.level <= -10) {
            relationship.type = 'enemy';
        } else if (relationship.level <= -3) {
            relationship.type = 'hostile';
        } else if (relationship.level < 3) {
            relationship.type = 'neutral';
        } else if (relationship.level < 10) {
            relationship.type = 'friendly';
        } else {
            relationship.type = 'friend';
        }
    }

    /**
     * Obtém o relacionamento entre duas bactérias
     * @param {Bacteria} b1 - Primeira bactéria
     * @param {Bacteria} b2 - Segunda bactéria
     * @returns {Object|null} - Relacionamento ou null se não existir
     */
    getRelationship(b1, b2) {
        const id1 = this.getBacteriaId(b1);
        const id2 = this.getBacteriaId(b2);
        
        if (!this.relationships.has(id1)) {
            return null;
        }
        
        return this.relationships.get(id1).find(r => r.partnerId === id2);
    }

    /**
     * Obtém um ID único para uma bactéria
     * @param {Bacteria} bacteria - Bactéria
     * @returns {number} - ID único
     */
    getBacteriaId(bacteria) {
        // Verifica se a bactéria já tem um ID
        if (!bacteria.communicationId) {
            // Atribui um ID baseado na posição no array
            const index = this.simulation.bacteria.indexOf(bacteria);
            bacteria.communicationId = index + 1;
        }
        
        return bacteria.communicationId;
    }

    /**
     * Retorna a hora formatada para o timestamp das mensagens
     * @returns {string} - Hora formatada (HH:MM:SS)
     */
    getFormattedTime() {
        const now = new Date();
        const hours = now.getHours().toString().padStart(2, '0');
        const minutes = now.getMinutes().toString().padStart(2, '0');
        const seconds = now.getSeconds().toString().padStart(2, '0');
        return `${hours}:${minutes}:${seconds}`;
    }
}

// Exporta a classe para o escopo global
window.BacteriaCommunication = BacteriaCommunication; 